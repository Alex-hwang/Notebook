# C++

[TOC]



## 一、基础储备

### 1. 初识

#### 1.1 注释

* 单行注释：```//描述信息```
* 多行注释：```/*描述信息*/```

#### 1.2 常量

1. ```#define 宏常量```
2. ```const 数据类型 常量名 = 常量值;```
   * 常量关键字`const`常用于修饰变量、引用/指针、函数返回值等
   * 修饰变量时(如`const int n = 1;`)必须就地初始化该变量的值在其**生命周期内都不会发生变化**
   * 修饰引用/指针时(如`int a = 1; const int& b = a;`)不能通过该引用/指针修改相应变量的值，常用于函数参数以**保证函数体中无法修改参数的值**
   * 修饰函数返回值时(如`const int* func() {...}`)函数返回值的内容(或其指向的内容)**不能被修改**

#### 1.3 数据类型

##### 1.3.1 整型

|    数据类型     | 占用空间 |        取值范围         |
| :-------------: | :------: | :---------------------: |
|   ```short```   |  2字节   | $-2^{15} \sim 2^{15}-1$ |
|    ```int```    |  4字节   | $-2^{31} \sim 2^{31}-1$ |
|   ```long```    |  4字节   | $-2^{31} \sim 2^{31}-1$ |
| ```long long``` |  8字节   | $-2^{63}\sim 2^{63}-1$  |

##### 1.3.2 浮点型

|   数据类型   | 占用空间 |  有效数字范围   |
| :----------: | :------: | :-------------: |
| ```float```  |  4字节   |   7位有效数字   |
| ```double``` |  8字节   | 15~16位有效数字 |

##### 1.3.3 字符型

```char ch = 'a';``` 占用1字节

**单引号里面是单个字符**

##### 1.3.4 字符串型

* C风格：
  * ```char str[] = "Hello world!";```
* C++风格：
  * ```std::string str = "Hello Wolrd!";```

##### 1.3.5 布尔类型

```bool flag = true;```

* true -- 1
* false -- 0

#### 1.4 数据的输入和输出

##### 1.4.1 输入

```std::cin >> str;```

##### 1.4.2 输出

```std::cout << "Hello World" << std::endl;```

#### 1.5 指针

##### 1.5.1 ```NULL```在C++中被明确定义为整数```0```：

```c++
/* Define NULL pointer value */
#ifndef NULL
    #ifdef __cplusplus
        #define NULL    0
    #else  /* __cplusplus */
        #define NULL    ((void *)0)
    #endif  /* __cplusplus */
#endif  /* NULL */
```

*在C中，`NULL`通常被定义为一个`void *`指针：*

~~~c
```#define NULL    ((void *)0)1```
~~~

##### 1.5.2 ```nullptr```(C++11)表示严格意义上的空指针

##### 1.5.3 两种指针的选择

* 减少`NULL`的使用(C++11之前)

  * 定义一个函数，并对它进行调用

  ```c++
  void f(int x,int y){..}
  f(2，0);
  //如果我们想对这个函数进行重载，并传入一个空指针作为参数
  void f(int x,double *y){..}
  f(2，NULL);
  // 实际调用的不是我们所期望的f(2，static cast<double *>(0));
  //当我们使用NULL表示空指针时，容易忽略它同时是一个int型常量。
  
  void f(int x, int y){
      cout<<"int"<<endl;
  }
  void f(int x, double *y){
      cout<<"pointer"<<endl;
  }
  f(2,nullptr);
  //Output: pointer
  ```

#### 1.6 基于范围的```for```循环

* 在循环头的圆括号中，由冒号```:```分为两部分，第一部分是用于迭代的变量，第二部分则表示将被迭代的范围

* 代码示例

  ```c++
  #include<iostream>
  using namespace std;
  int main() {
      int arr[3] = {1,3,9};
      for(int e : arr) //auto e : arr 也可以
          cout << e << endl;
      return 0;
  }
  ```


#### 1.7 ```auto```关键字

* **`auto`** 关键字指示编译器使用已声明变量的初始化表达式或 lambda 表达式参数来推导其类型。

* 在大多情况下，建议使用 **`auto`** 关键字（除非确实需要转换），因为此关键字具有以下好处：

  - **可靠性：**如果表达式的类型发生更改（包括函数返回类型发生更改的情况），它也能工作。

  - **性能：**确保不会进行转换

  - **可用性：**不必担心类型名称拼写困难和拼写有误

    ```c++
    map<int,list<string>>::iterator i = m.begin();
    auto i = m.begin();
    ```

  - **效率：**代码会变得更高效

* 可能不需要使用 **`auto`** 的转换情况：

  - 你需要一个特定类型，任何其他类型都不行。
  - 例如，在表达式模板帮助程序类型 `(valarray+valarray)` 中

* **`auto`** 初始化表达式可以采用多种形式：

  - 通用初始化语法，例如 `auto a { 42 };`
  - 赋值语法，例如 `auto b = 0;`
  - 通用赋值语法，它结合了上述两种形式，例如 `auto c = { 3.14159 };`
  - 直接初始化或构造函数样式的语法，例如 `auto d( 1.41421f );`

* 当 **`auto`** 用于在基于范围的 **`for`** 语句中声明循环参数时，它使用不同的初始化语法，例如`for (auto& i : iterable) do_action(i);`

* **`auto`** 关键字是类型的占位符，但它本身不是类型。 因此，**`auto`** 关键字不能用于强制转换或运算符，如 `sizeof`

#### 1.8 引用

##### 1.8.0 左值和右值

* 左值：可以取地址、有名字的值
* 右值：不能取地址、没有名字的值，常见于常值、函数返回值、表达式

* 判断某个表达式是左值还是右值的方法：

  ① 可位于赋值号`=`左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。

  ② 有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。

##### 1.8.1 左值引用

* 左值可以取地址，并且可以被`&`引用(左值引用)

```c++
int *d = &a;
int &d = a;
int *e = &(a + b);
int &e = a + b;
```

##### 1.8.2 右值引用

* 虽然右值无法取地址，但可以被`&&`引用(右值引用)

  ```c++
  int &&e = a + b;  
  ```

* 右值引用无法绑定左值

  ```c++
  int &&e = a;//错误
  ```

##### 1.8.3 左值引用能绑定左值，右值引用能绑定右值

* 例外：常量左值引用能也绑定右值

### 2.核心

#### 2.0 面向对象

* 程序 = 算法 + 数据结构
* 设计范式： 程序 = 对象 + 消息
* **对象**是任何具备属性和行为两种要素的事物，在C++中的对象都是**数据**和**函数**两部分组成，通过**类**来描述
  * 对象的两要素
    * 静态属性（数据）
    * 动态行为（方法、函数）
  * 对象的内存分配
    * 用类来定义对象时，系统自动为每一个对象分配储存空间
    * 对象占用的储存空间就是数据成员所占用的空间
  * 对象的引用
    * 通过对象名和成员运算符访问```person.display();```
    * 通过指向对象的指针来访问```person -> display;``` 
    * 通过对象的引用变量来访问
* **类**是用来描述相同对象的共同特征的对象的抽象，对象是类的具体实例
  * 类是抽象的，不占用内存；对象是具体的，要占用内存
  * 类的属性
    * 封装性
      * 进行数据和行为的绑定关联
      * 引入访问限定，实现共用接口和私有接口的分离
        * ```private```类内可以访问，类外不可访问（子不可访问父）
        * ```public```类内可以访问，类外可以访问
        * ```protected```类内可以访问，类外不可访问
* 成员函数

  * 性质
    * 具有返回值和函数类型
    * 可以访问本类中的任何成员
    * 可以类内定义也可以类外定义
  * 定义
    * 在类内定义不需要加上作用域限定符```::```
    * 在类内定义必须要加上作用域限定符```::```
  * ```inline```成员函数
    * 在编译时将背调函数的代码直接展开到主调函数中，而不是在函数执行时将流程转出去
    * 声明方法```inline int sum(int x, int y);```
    * 注意
      1. 避免对大段代码使用内联修饰符。内联修饰特相当于把该函数在所有被调用的地方拷贝了一份，所以大段代码的内联修饰会增加负担。(代码膨胀过大)
      2. 避免对包含循环或者复杂控制结构的函数使用内联定义。因为内联函数优化的，只是在函数调用的时候，会产生的压栈、跳转、退栈和返回等操作。所以如果函数内部执行代码的时间比函数调用的时间长得多，优化几乎可以忽略
      3. 避免将内联函数的声明和定义分开编译器编译时需要得到内联函数的实现，因此多文件编译时内联函数先需要将实现写在头文件中，否则无法实现内联效果。
      4. 定义在类声明中的函数默认为内联函数。
      5. 一般构造函数、析构函数都被定义为内联函数。
  * C++为类中的每个成员函数专门设立了一个```this```指针。这个指针指向本类对象，它的值是当前被调用的成员函数所在的对象的**起始地址**

#### 2.1 构造函数与析构函数

##### 2.1.1构造函数

* 定义

  * 是一种特殊的成员函数，主要作用是为对象成员属性赋值

* 特点

  * 必须是```public```成员
  * 由编译器自动调用，无需手动调用
  * 名称必须与类同名，不能自由命名
  * 没有返回值但是也不写```void```

* 类型

  * 默认构造函数（无参，函数体为空）

  * 默认析构函数（无参，函数体为空）

  * 默认拷贝构造函数，对属性进行值拷贝

    * 被调用的三种情况，编译器会自动调用**拷贝构造函数**，在已有对象基础上生成新对象。

      * 用一个类对象定义另一个新的类对象

        `Test a; Test b(a);` `Test c = a;`    

      * 函数调用时以类的对象为形参     

        `Func(Test a)`

      * 函数返回类对象

        `Test Func(void)`

    * 执行顺序

      ![image-20240412221527063](C:\Users\22539\AppData\Roaming\Typora\typora-user-images\image-20240412221527063.png)

    * **频繁的拷贝构造会造成程序效率的显著下降**

    * 正常情况下，应尽可能避免使用拷贝构造函数，解决方法：

      （1）使用**引用/常量引用**传参数或返回对象；

      （2）将拷贝构造函数**声明为`private`**；

      （3）用`delete`关键字让编译器不生成拷贝构造函数的**隐式定义**版本。

* 调用规则

  如果用户定义有参构造函数，C++不再提供默认无参构造函数，但是会提供默认拷贝构造；如果用户定义有拷贝构造函数，C++不会再提供其他构造函数。

* 参数初始化表```Person::Person(int age, std::string name) : m_Age(age), m_Name(name) { }```

* 构造函数的重载

  * 参数个数或者类型不同
  * 即使定义有重载的多个构造函数，但是实际执行时只会执行一个构造函数

* 带有默认参数的构造函数

  * 从左到右依次结合
  * 如果用户指定参数，那么采用用户指定的参数，否则使用默认参数
  * 如果有默认参数必须从此参数开始**往后的所有参数都有默认值**
  * 如果有全默认参数的构造函数，就不能有重载构造函数，否则产生二义性

  ```java
  class Person{
  public:
     int m_Age;
     //默认构造（无参构造）
     Person() {
     }
     //有参构造
     Person(int a) {
     }
     //拷贝构造
     Person(const Person& p) {
     }
  };
  
  int main() {
     Person p;
     p.m_Age = 18;
     Person p2(p);
     return 0;
  }
  //第一次构造函数是在创建p时调用默认构造函数
  //第二次构造函数是创建p2时调用的拷贝构造函数
  //如果没有自定义拷贝构造函数仍可以正常运行，编译器会提供拷贝构造函数
  ```

* 拷贝构造函数
  * 深拷贝：在堆区重新申请空间，进行拷贝操作
  * 浅拷贝：简单的复制拷贝操作

  ```java
  class Person{
  public:
     Person() {
     }
     ~Person() {
     }
     Person(int age) {
        m_Age = age;
     }
     Person(const Person& p) {
        m_Age = p.m_Age;
     }
     int m_Age;
  }
  //用一个已经创建完毕的对象来初始化一个新的对象
  void test01() {
     Person p1(20);
     Person p2(p1);//拷贝构造函数
  }
  //值传递的方式给函数参数传值
  void doWork(Person p) {
  }
  
  void test02() {
     Person p;
     doWork(p);//调用这个函数的时候就会调用拷贝构造函数，创建一个副本
  }
  //值方式返回局部对象
  Person test03() {
     Person p1;
     return p1;//在返回时会拷贝一个副本进行返回
  }
  void test04() {
     Person p = test03();
  }  
  ```

* 对象的隐式复制
  * 函数调用时参数值传入
  * 函数调用时返回值传出

> [!IMPORTANT]
>
> **如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题**

##### 2.1.2 析构函数

* 定义：是一个特殊的成员函数，它的作用与构造函数相反
* 特点
  * 必须是```public```成员
  * 没有返回值也不写```void```
  * 函数名称与类名称相同，在前面加上```~```
  * 不能有参数，不能重载
  * 在对象销毁之前程序自动调用一次，不需要手动调用

```java
class Person {
public:
   //无参（默认）构造函数
   Person() {
      cout << "无参构造函数" << endl;
   }
   //有参构造函数
   Person(int age, int height) {
      cout << "有参构造函数" << endl;
      m_Age = age;
      m_Name = name;
   }
   //拷贝构造函数
   Person(const Person& p) {
      cout << "拷贝构造函数" << endl;
      //如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区的问题
      m_Age = p.m_Age;
      m_Height = new int(*p.m_Height);
   }
   //析构函数
   ~Person() {
      cout << "析构函数" << endl;
      if(m_Height != NULL) {
         delete m_Height;
      }
   }
public:
   int m_Age;
   int* m_Height;
};

void test01() {
   Person p1(18, 180);
   Person(p1);
   cout << "p1的年龄：" << p1.m_Age << "身高：" << p1.m_Height << endl;
   cout << "p2的年龄：" << p2.m_Age << "身高：" << p2.m_Height << endl;
}

int main() {
   test01();
   system("pause");
   return 0;
}
```

##### 2.1.3 生命周期

###### 2.1.3.0 内存分区模型

* 不同区域存放不同数据，赋予不同的生命周期，给我们更大的灵活编程
  * 代码区：存放函数体的二进制代码，由操作系统进行管理。
  * 全局区：存放全局变量和静态变量以及常量
  * 栈区：由编译器自动分配释放，存放函数的参数值、局部变量等
  * 堆区：由程序员分配和释放，若程序员不释放，程序结束时由系统回收

- **在程序运行前**，生成了`.exe`可执行程序，未执行该程序之前分为两个区域：
  - **代码区**，存放CPU执行的机器指令。代码区是共享的，共享的目的是对于频繁执行的程序，只需要在内存中有一份代码即可；代码区是只读的，为了防止程序意外地修改它的指令。
  - **全局区**，全局变量和静态变量（`static 变量类型 变量名;`）存放在此，全局区还包括了常量区，字符串常量和其他常量也存放于此，该区域的数据在程序运行结束知乎由系统释放。

- **在程序运行后**，栈区由编译器自动分配释放，存放函数的参数值、局部变量等。

  - 不要返回局部变量的地址，栈区开辟的数据由编译器自动释放。

  - 堆区由程序员分配和释放，若程序员不释放，程序结束时由系统回收。

    - 主要利用new在兑堆区开辟数据，语法为：`new 数据类型` 会返回该数据对应的指针

    ```java
    int* func() {
       int* p = new int(10);
       return p;
    }
    
    void test() {
       int* p = func();
       cout << *p << endl;
       delete p;//删除之后如果再次访问就是非法操作，会报错！
    }
    
    int main() {
       test();
       system("pause");
       return 0;
    }
    
    //注意，如果new开辟的是一个数组，释放操作应该修改如下：
    //Date* p = new Date[10];
    //delete []p;
    ```

    

###### 2.1.3.1 变量的生命周期

* 定义：从变量被分配空间到空间被收回的这一个时间段，称为变量的`生命周期`
* `C++`有如下几种存储方案，存储方案不同，其变量生命周期也不一样。
  - **自动存储**：如函数定义时声明的变量就属于自动存储类别。生命周期较短，仅在函数被调用到函数执行结束后其内存就会被释放。
  - **静态存储**：在函数定义外声明的变量、使用关键字`static`声明的变量都为静态存储类别。它们在整个程序运行过程中都存在。
  - **线程存储**：在并发、并行环境中，如果变量使用关键字 `thread_local`声明，则生命周期和所依附的线程生命周期同步。
  - **动态存储**：使用 `new`运算符声明的变量，其存储块一般在堆中，如果开发者不显示释放（`delete`）会一直存在，直到程序结束。

###### 2.1.3.2 对象的生命周期

- 自动对象（Automatic Objects）：自动对象是在函数内部或者代码块内部定义的对象，它的生命周期与其所在的作用域相对应。当作用域结束时，自动对象会自动被销毁。
- 静态对象（Static Objects）：静态对象是在函数外部或者全局作用域中定义的对象，它在程序执行期间一直存在，直到程序结束。静态对象的生命周期由程序的生命周期决定。
- 动态对象（Dynamic Objects）：动态对象是通过动态内存分配（new、malloc等）创建的对象。动态对象的生命周期由程序员手动控制，通过调用delete或free来显式释放对象所占用的内存。

##### 2.1.4 构造函数和析构函数的调用时机

1. 在全局范围内定义的对象（在所有函数之外）的构造函数在文件中的所有函数执行之前调用。但是如果一个程序中有多个文件，不同的文件中都定义了全局对象，那这些对象构造函数的执行顺序是不确定的。当主函数执行完毕或者调用```exit```函数（程序终止）调用析构函数。
2. 如果定义的是局部自动变量（在函数中定义对象）那么在建立对象时调用构造函数。如果函数被多次调用，那么在每次调用时都会调用构造函数。在函数调用结束、对象释放时先调用析构函数。
3. 如果在函数中定义静态（```static```）局部对象，那么只在程序第一次调用此函数建立对象时调用一次构造函数，在调用结束时并不释放，因此也不调用析构函数，只在主函数结束或调用```exit```函数结束程序时才调用析构函数
4. 如果在函数中使用了```new```运算符，构建了一个动态临时对象，其生命周期从```new```运算符开始，此时调用构造函数。在执行的指针采用```delete```运算符释放时，对象生命周期结束，此时调用析构函数

#### 2.2 对象的动态构建与释放

##### 2.2.0 为什么需要动态构建与释放

*静态方式构建的对象在程序运行过程中，所占用的空间直至对象的生存周期结束时才由系统自动释放。为了提高内存空间的使用率，我们希望能够在需要使用的时候建立对象，不需要使用的时候能够撤销，释放其空间，所以引入了动态方式构建*

##### 2.2.1 使用方法

* ```new 数据类型``` 会返回该数据对应的指针
* ```delete 数据类型``` 会释放所占用的空间

```java
int* func() {
   int* p = new int(10);
   return p;
}

void test() {
   int* p = func();
   cout << *p << endl;
   delete p;//删除之后如果再次访问就是非法操作，会报错！
}

int main() {
   test();
   system("pause");
   return 0;
}

//注意，如果new开辟的是一个数组，释放操作应该修改如下：
//Date* p = new Date[10];
//delete []p;
```

#### 2.3 对象数组和对象指针

##### 2.3.1 对象数组

* 定义：若干同类对象的对象集合
* 特点：
  * 定义时编译器会调用每一个数组分量的构造函数，如果数组定义没有提供初始参数，那么就会调用无参构造函数
* ```类名 对象名[长度] = {构造函数(实参列表1), 构造函数(实参列表2), ……}```

##### 2.3.2 对象指针

* 定义：构建一个对象时，给该对象在内存中分配一定大小的连续空间，用来保存对象中的成员函数和数据成员。这些数据和函数所占用的内存单元的起始地址被称为相关的指针。
* ```类名* 对象指针名```
* `(*指针变量名).数据成员(或成员函数);` `指针变量名 -> 数据成员(或成员函数)`
* 指向对象成员的指针
  * 函数参数的类型和参数个数匹配
  * 函数返回值的类型匹配
  * 所属的类型匹配
  * ```数据类型名 (类名::*指针变量名)(参数表列);```
  * ```指针变量名 = &类名::成员函数名;```

#### 2.4 共用数据的保护

##### 2.4.0 常变量属性

* 是指某一变量在初始化之后，只能被读取，不能被修改。这样使得变量既能在一定范围内共享，又保证它不会被任意修改。

##### 2.4.1 常对象和常成员函数

###### 2.4.1.1 常对象

* 如果希望保证对象中的数据成员不被改变，就可以声明这个对象为常对象。但是若对象被定义为常量，则它只能调用以```const```修饰的成员函数

  ```c++
  //类名 const 对象名; or const 类名 对象名;
  //例如 
  Time const t1(12,34,36); //定义t1为常对象
  ```

* 注意事项

  * 在定义常对象时必须进行初始化；
  * 常对象的成员属性不能进行更新；
  * 常对象不能调用该对象中非常成员函数(非```const```函数)，否则系统会报错误。
    * 目的：防止非```const```成员函数修改常对象中的成员属性的值，因为```const```成员函数是不可以修改对象中成员属性的值

###### 2.4.1.2 常成员函数

* 定义方法：```函数类型 函数名(参数列表) const;```
  * 在声明和定义的时候都需要加上`const`在调用的时候不需要
* 注意事项
  * 将成员函数声明称常成员函数只能引用本类中的数据成员，常成员函数可以引用`const`数据成员也可以引用非`const`的数据
  * 常成员函数不能调用另一个非常成员函数

###### 2.4.1.3 `mutable`关键字

* 在C++中，`mutable`也是为了突破`const`的限制而设置的。被`mutable`修饰的变量，将永远处于可变的状态，即使在一个`const`函数中

```c++
class Driver {
private:
  // real phone number
  string phone;
  // display phone number
  mutable string displayPhone;

public:
  string getDisplayPhone() const {
    if (needUpdate()) {
      lock.lock();
      if (needUpdate()) {
        updateDisplayPhone(); // displayPhone在这里被改变
      }
      lock.unlock();
    }
    return displayPhone;
  }
};
```

##### 2.4.2 对象的常数据成员

* 如果一个类中，有些数据成员的值允许改变，另一些数据的值不允许改变，可以将不允许改变的数据声明为`const`，当然也可以用非`const`的成员函数来读取这些数据值或者修改非`const`的值
* 如果一个类中所有数据成员的值都不允许改变，那就将对象声明为`const`，常对象只能调用常成员函数，不能调用非常成员函数

##### 2.4.3 指向对象的常指针和指向常对象的指针变量

* 如果希望指针变量在初始化之后就不能改变，那么可以将指针变量声明为`const`

##### 2.4.4 指向常对象的指针变量

* 如果一个变相已经被声明为常变量，那么只能用指向常变量的指针来指向，但是不能改变值
* 指向常变量的指针也可以指向非常变量
* 如果函数的形参是指向非`const`的指针，实参只能用指向非常变量的指针，而不能用指向常变量的指针
* 如果函数的形参是指向`const`的指针，实参可以`const`也可以非`const`

##### 2.4.5 对象的常引用

* 如果我们不想给于函数修改权限，那么可以在参数中使用常量引用
* 使用方法`void add(const int& a, const int& b)`
* <u>拷贝构造函数是一种特殊的**构造函数**，也是**同类对象**的常量引用</u>
  * `Person(const Person& per) { ... }`
  * 用参数对象的内容初始化当前对象

##### 2.4.6 最小特权原则

* 最小特权原则：给函数足够的权限去完成相应的任务，但不要给予他多余的权限。
* 例如函数`void add(int& a, int& b)`如果将参数类型定义为`int&`则给予该函数在函数体内修改a和b的值的权限

#### 2.5 同类对象间的数据共享以及类的静态成员







